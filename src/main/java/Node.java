//Reliable broadcast library
//Implement a library for reliable broadcast communication among a set of faulty processes, plus a simple application to test it (you are free to choose the application you prefer to highlight the characteristics of the library).
//The library must guarantee virtual synchrony, while ordering should be at least fifo.
//The project can be implemented as a real distributed application (for example, in Java) or it can be simulated using OmNet++.
//Assumptions:
//Assume (and leverage) a LAN scenario (i.e., link-layer broadcast is available).
//You may also assume no processes fail during the time required for previous failures to be recovered.

import java.awt.*;
import java.io.IOException;
import java.net.InetAddress;
import java.util.List;

public class Node {
    private List<InetAddress> view;
    private List<Integer> viewTimers;
    private int id;
    private InetAddress address;
    private int port;
    private String state;

    //autogenerated id, autoincrement
    private static int idCounter = 0;

    public Node(InetAddress address, int port, String state) {
        this.id = idCounter++;
        this.address = address;
        this.port = port;
        this.state = state;
    }

    public Node(InetAddress address, int port, String state, List<InetAddress> view, List<Integer> viewTimers) {
        this.id = idCounter++;
        this.address = address;
        this.port = port;
        this.state = state;
        this.view = view;
        this.viewTimers = viewTimers;
    }


    public void processMessage(Message message) {
        switch (message.getType()) {
            case STRING:
                // print the message
                if (message instanceof StringMessage) {
                    StringMessage stringMessage = (StringMessage) message;
                    System.out.println(stringMessage.getMessage());
                }
                break;
            case JOIN:
                // add the new node to the view
                if (message instanceof JoinMessage) {
                    JoinMessage joinMessage = (JoinMessage) message;
                    view.add(joinMessage.getNode().address);
                }
                break;
            case VIEW_CHANGE:
                // update the view
                if (message instanceof ViewChangeMessage) {
                    ViewChangeMessage viewChangeMessage = (ViewChangeMessage) message;
                    view = viewChangeMessage.getView();
                }
                break;
            case PING:
                // reset the timer for the sender
                if (message instanceof PingMessage) {
                    PingMessage pingMessage = (PingMessage) message;
                    //send messsage back to the sender of the ping
                    //TODO: send(new AckMessage(this.address, pingMessage.getSequenceNumber(), this.id, pingMessage.getSource()));
                }
                break;
        }
    }

    //Every node is listening for incoming messages. When a message is received, the node processes it.
    //The listening process is done in a separate thread.

    public void listenThread() {
        ListeningTask listeningTask = new ListeningTask(this, port);
        Thread listeningThread = new Thread(listeningTask);
        listeningThread.start();
    }

    // sending a message to all view members (broadcast)
    public void send(String message) {
        //for (Node node : view)
    }


    // Getters and setters

    public List<InetAddress> getView() {
        return view;
    }

    public List<Integer> getViewTimers() {
        return viewTimers;
    }

    public void setView(List<InetAddress> view) {
        this.view = view;
    }

    public void setViewTimers(List<Integer> viewTimers) {
        this.viewTimers = viewTimers;
    }

    public int getId() {
        return this.id;
    }

    public InetAddress getAddress() {
        return this.address;
    }

    public int getPort() {
        return this.port;
    }

    public String getState() {
        return this.state;
    }

    public void setState(String state) {
        this.state = state;
    }

}