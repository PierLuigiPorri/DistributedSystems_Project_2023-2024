package Client;//Reliable broadcast library
//Implement a library for reliable broadcast communication among a set of faulty processes, plus a simple application to test it (you are free to choose the application you prefer to highlight the characteristics of the library).
//The library must guarantee virtual synchrony, while ordering should be at least fifo.
//The project can be implemented as a real distributed application (for example, in Java) or it can be simulated using OmNet++.
//Assumptions:
//Assume (and leverage) a LAN scenario (i.e., link-layer broadcast is available).
//You may also assume no processes fail during the time required for previous failures to be recovered.

import Client.Tasks.DeliverTask;
import Client.Tasks.ReceiverTask;
import Messages.Message;

import java.net.InetAddress;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.LinkedBlockingQueue;

public class Node {
    private List<Peer> view;
    private HashMap<Integer, Integer> viewTimers;
    private int id;
    private String Nodestate; //It is an ENUM with all possible states of a node. It can be, for example: "Joining", "Active", "Leaving", "Failed"
    //autogenerated id, autoincrement
    private static int idCounter = 0;

    private LinkedBlockingQueue<Message> messageQueue;
    //TODO: unstable messages and committed messages
    private LinkedBlockingQueue<Message> sendingMessageQueue;

    public Node() {
        this.id = idCounter++;
        this.messageQueue = new LinkedBlockingQueue<>();
    }

    public Node(List<Peer> view) {
        this.id = idCounter++;
        this.view = view;
        this.messageQueue = new LinkedBlockingQueue<>();
    }

    public void queueMessage(Message message){
        this.messageQueue.add(message);
    }

    public Message dequeueMessage() throws InterruptedException {
        return this.messageQueue.take();
    }

    //Every node is listening for incoming messages. When a message is received, the node processes it.
    //The listening process is done in a separate thread.



    // sending a message to all view members (broadcast)
    public void send(String message) {
        //for (Client.Node node : view)
    }

    public void initializeTimer() {
        //TODO: for (Client.Node node : view)
    }

    // Getters and setters

    public List<Peer> getView() {
        return view;
    }

    public HashMap<Integer, Integer> getViewTimers() {
        return viewTimers;
    }

    public void setView(List<Peer> view) {
        this.view = view;
    }

    public void setViewTimers(HashMap<Integer, Integer> viewTimers) {
        this.viewTimers = viewTimers;
    }

    public int getId() {
        return this.id;
    }

    public String getNodestate() {
        return this.Nodestate;
    }

    public void setNodestate(String nodestate) {
        this.Nodestate = nodestate;
    }
}